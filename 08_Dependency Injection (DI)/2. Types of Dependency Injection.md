
---

## C# Types of Dependency Injection

While **Constructor Injection** is the industry standard, there are actually three main ways to "inject" (pass) dependencies into a class.

### 1. Constructor Injection (The Gold Standard)

This is the most common and recommended approach (used in 95% of cases).

You pass the dependency via the Constructor.

- **Pros:** guarantees the class is fully initialized (it _cannot_ exist without its dependency).
    
- **Cons:** The constructor can get messy if there are too many dependencies.
    

C#

```C#
public class CustomerService
{
    private readonly ILogger _logger;

    // The class demands an ILogger immediately upon creation.
    // "I cannot exist without a Logger."
    public CustomerService(ILogger logger)
    {
        _logger = logger;
    }

    public void Save()
    {
        _logger.Log("Customer saved.");
    }
}

// Usage
ILogger log = new ConsoleLogger();
var service = new CustomerService(log); // Must provide it here
```

### 2. Setter (Property) Injection

You expose a **public property** to let the caller set the dependency later.

- **Pros:** Good for **optional** dependencies (e.g., a logger that isn't strictly required).
    
- **Cons:** The dependency might be `null` when you try to use it. You always have to check.
    

C#

```C#
public class CustomerService
{
    // It's public, so it can be changed from the outside.
    public ILogger Logger { get; set; }

    public void Save()
    {
        // Check if it was set before using!
        if (Logger != null)
        {
            Logger.Log("Customer saved.");
        }
    }
}

// Usage
var service = new CustomerService();
// We can set it later, or not at all
service.Logger = new ConsoleLogger(); 
```

### 3. Interface (Method) Injection

You pass the dependency **directly into the method** that needs it. The class does not store the dependency as a field.

- **Pros:** Great if the dependency varies every time (e.g., using a different payment method for each checkout).
    
- **Cons:** You have to pass it every time you call the method.
    

Here is the code implementing **Interface Injection** based on your screenshot.

In this pattern, the class (`Builder`) implements an interface (`IToolUser`) that forces it to have a method (`SetTools`) where the dependencies are injected.

C#

```C#
// 1. Define the dependencies
public class Hammer
{
    public void Use() => Console.WriteLine("Hammering nails...");
}

public class Saw
{
    public void Use() => Console.WriteLine("Sawing wood...");
}

// 2. The Interface 
// This acts as a contract: "If you want to use tools, you MUST have a method to accept them."
public interface IToolUser
{
    void SetTools(Hammer hammer, Saw saw);
}

// 3. The Class (Builder)
public class Builder : IToolUser
{
    private Hammer _hammer;
    private Saw _saw;

    // Interface Injection Implementation
    // This method is required by IToolUser
    public void SetTools(Hammer hammer, Saw saw)
    {
        _hammer = hammer;
        _saw = saw;
    }

    public void BuildHouse()
    {
        Console.WriteLine("Starting construction...");
        _hammer.Use();
        _saw.Use();
        Console.WriteLine("House built!");
    }
}

// 4. Usage
public class Program
{
    static void Main()
    {
        // Create the Builder (It has no tools yet)
        Builder builder = new Builder();

        // Create the tools
        Hammer h = new Hammer();
        Saw s = new Saw();

        // INJECT them using the Interface method
        builder.SetTools(h, s);

        // Now we can work
        builder.BuildHouse();
    }
}
```

---

### Summary Comparison

|**Type**|**Syntax**|**Best For**|**Risk**|
|---|---|---|---|
|**Constructor**|`new Class(service)`|**Required dependencies.** (Database, Services)|None (Safest).|
|**Setter**|`obj.Service = ...`|**Optional dependencies.** (Logging, Analytics)|Might be `null` when used.|
|**Method**|`obj.Do(service)`|**Varying dependencies.** (Strategies, Payment)|Annoying to pass every time.|