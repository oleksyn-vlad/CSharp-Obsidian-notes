
---

## C# Decoupling & Testability

**Coupling** refers to how dependent two classes are on each other.

- **Tight Coupling (Bad):** Class A creates Class B directly using the `new` keyword. If you change B, you break A.
    
- **Loose Coupling (Good):** Class A asks for an Interface (`IMyClass`) and doesn't care what the specific implementation is.
    

### 1. The Problem: Tightly Coupled Code

When a class creates its own dependencies (using `new`), it is "hard-wired".

**Analogy:** Imagine a lamp that is hard-wired directly into the wall. If the bulb breaks, you have to tear down the wall to fix it. You cannot swap it for a different lamp easily.

C#

```C#
public class Car
{
    // TIGHT COUPLING
    // The Car creates the Engine itself.
    // We cannot change the engine type without rewriting the Car class.
    private PetrolEngine _engine = new PetrolEngine();

    public void Start()
    {
        _engine.Start();
    }
}
```

### 2. The Solution: Loosely Coupled Code

Instead of creating the dependency, the class **asks for it**. This usually involves using **Interfaces**.

**Analogy:** A standard wall socket. You can plug in a Lamp, a TV, or a Vacuum. The wall doesn't care what it is, as long as it has a plug (Interface).

C#

```C#
public class Car
{
    // LOOSE COUPLING
    // We rely on an Interface (Abstraction), not a specific class.
    private IEngine _engine;

    // We ask for the engine via the Constructor
    // (Someone else must give it to us)
    public Car(IEngine engine)
    {
        _engine = engine;
    }

    public void Start()
    {
        _engine.Start();
    }
}
```

### 3. Why is this better? (Testability)

Decoupling is crucial for **Unit Testing**.

- **Scenario:** You want to test if the `Car` logic works.
    
- **Tightly Coupled:** You have to start a real `PetrolEngine`. If the engine is complex (e.g., connects to a database), the test becomes slow and fragile.
    
- **Loosely Coupled:** You can inject a **Fake Engine** (Mock) that just says "I started" without doing any heavy lifting. This allows you to test the `Car` in isolation.
    

---

Here is the combined note covering **Decoupling** and **Dependency Injection (DI)**.

---

## C# Decoupling & Dependency Injection (DI)

### 1. The Problem: Tight Coupling (Hard-Wired)

**Coupling** refers to how dependent two classes are on each other.

- **Tight Coupling (Bad):** Class A creates Class B directly using the `new` keyword. If you change B, you break A.
    

**Analogy:** Imagine a coffee shop where the espresso machine is built directly into the counter. If it breaks or you want to upgrade, you have to tear down the whole counter.

C#

```C#
// BAD: Tight Coupling
public class UserService
{
    // UserService is responsible for CREATING EmailService.
    // They are glued together.
    private EmailService _emailService = new EmailService();

    public void Register(string name)
    {
        _emailService.Send("Welcome!");
    }
}
```

### 2. The Solution: Dependency Injection (DI)

Dependency Injection means "don't create your dependencies; ask for them."

Instead of a class creating the tools it needs (like a Database or EmailService), those tools are injected into the class from the outside.

**Analogy:** Renting a coffee machine. If it breaks, you just unplug it and plug in a new one. The counter (your class) doesn't care which specific machine is plugged in, as long as it makes coffee.

### 3. Implementing DI (Constructor Injection)

This is the most common form of DI. You pass the dependency into the Constructor.

Crucially, we use an Interface (IEmailService) instead of a concrete class to achieve Loose Coupling.

C#

```C#
// 1. The Contract (Interface)
public interface IEmailService
{
    void Send(string message);
}

// 2. The Implementation
public class EmailService : IEmailService
{
    public void Send(string message) => Console.WriteLine($"Sending: {message}");
}

// 3. The Consumer (Loosely Coupled)
public class UserService
{
    private readonly IEmailService _emailService;

    // INJECTION HAPPENS HERE:
    // We ask for the Interface. We don't care if it's the real email service
    // or a fake one for testing.
    public UserService(IEmailService emailService)
    {
        _emailService = emailService;
    }

    public void Register(string name)
    {
        _emailService.Send($"Welcome {name}!");
    }
}

// 4. Usage (Wiring it up)
class Program
{
    static void Main()
    {
        // We create the dependency first...
        IEmailService myMailer = new EmailService();
        
        // ...and inject it into the user service.
        UserService userSvc = new UserService(myMailer);
        
        userSvc.Register("John");
    }
}
```

### 4. Why do this? (Benefits)

1. **Decoupling:** `UserService` no longer relies on specific code inside `EmailService`. You can change the email logic without touching the user logic.
    
2. **Testability (The Big Win):** When writing Unit Tests, you don't want to send real emails. With DI, you can inject a **Mock** (fake) email service that just records that `Send()` was called.
    
3. **Maintainability:** It is easier to swap out components (e.g., switching from sending emails to sending SMS) because the system is modular.
    

### 5. Types of Injection

While Constructor Injection is the standard, there are other ways:

- Constructor Injection (Recommended): Dependencies are required to create the object.
    
    public MyClass(IService service) { ... }
    
- Property Injection (Setter): Dependencies are optional and can be set later.
    
    public IService Service { get; set; }
    
- Method Injection: Dependency is needed for just one specific method.
    
    public void DoWork(IService service) { ... }
    

### 6. DI Containers (Automating the Process)

In large apps (like ASP.NET Core), manually creating all these objects (new Service(new Repo(new DbContext...))) is tedious.

We use a DI Container to manage this automatically. You register your services once, and the container automatically injects them wherever they are needed.

C#

```C#
// Example in ASP.NET Core Program.cs
builder.Services.AddScoped<IEmailService, EmailService>();
builder.Services.AddScoped<UserService>();

// The app will now automatically handle the 'new' keywords for you.
```