Here is the note on Operator Overloading for your Obsidian vault.

---

## C# Operator Overloading

Operator overloading allows you to define custom behaviors for standard operators (like `+`, `-`, `==`, `*`) when applied to your custom classes or structs.

This makes code more intuitive, allowing you to write `obj1 + obj2` instead of `obj1.Add(obj2)`.

### 1. Syntax Rules

1. The method must be **`public`** and **`static`**.
    
2. You must use the **`operator`** keyword.
    
3. You must return a **new object** (do not modify the input parameters).
    

### 2. Implementation Example (Vector Addition)

Here is how to make the `+` symbol work for a custom `Vector` class.

C#

```C#
public class Vector
{
    public int X { get; set; }
    public int Y { get; set; }

    public Vector(int x, int y)
    {
        X = x;
        Y = y;
    }

    // --- The Operator Overload ---
    // Syntax: public static ReturnType operator Symbol (Type operand1, Type operand2)
    public static Vector operator +(Vector v1, Vector v2)
    {
        // Return a NEW instance containing the result
        return new Vector(v1.X + v2.X, v1.Y + v2.Y);
    }
}

// --- Usage ---
class Program
{
    static void Main()
    {
        Vector v1 = new Vector(3, 5);
        Vector v2 = new Vector(7, 2);

        // Now we can use the '+' symbol
        Vector result = v1 + v2; 
        
        Console.WriteLine($"Result: {result.X}, {result.Y}"); // Output: 10, 7
    }
}
```

### 3. Best Practices

- **Intuition:** Only overload operators if it makes logical sense (e.g., adding vectors or matrices). Don't use `+` to subtract.
    
- **Pairs:** If you overload comparison operators, you must overload their opposites:
    
    - If you overload `==`, you **must** overload `!=`.
        
    - If you overload `<`, you **must** overload `>`.
        
- **Immutability:** Operators should usually return a new result and not change the original operands (just like `5 + 5` returns `10` but doesn't change the number 5).