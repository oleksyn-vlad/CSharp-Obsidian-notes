
---

## C# Polymorphism

Polymorphism comes from Greek meaning "Many Forms".

In programming, it means treating different objects as the same general type, but letting them execute their own specific behavior.

### 1. The Concept (The "Is-A" Rule)

Because a Dog inherits from Animal, a Dog is an Animal.

This means you can store a Child object inside a Parent variable.

C#

```c#
// 1. Specific Type (Normal)
Dog myDog = new Dog();

// 2. Polymorphic Type (Upcasting)
// We store a 'Dog' in an 'Animal' variable.
Animal myPet = new Dog(); 
```

### 2. Why is this useful? (The "Zoo" Example)

Imagine you want to create a list of all animals in a zoo.

Without polymorphism, you would need separate lists: List<Пес>, List<Кіт>, List<Пташка>.

**With Polymorphism**, you make **one** list of `Animal`.

C#

```C#
List<Animal> zoo = new List<Animal>();

zoo.Add(new Dog());
zoo.Add(new Cat());
zoo.Add(new Bird());

// We treat them all as "Animals"
foreach (Animal a in zoo)
{
    // The Magic: 
    // Even though the variable 'a' is just an 'Animal',
    // C# knows which specific method to run!
    a.MakeSound(); 
}

// Output:
// "Bark!"
// "Meow!"
// "Chirp!"
```

### 3. The Two Types of Polymorphism

#### A. Static Polymorphism (Overloading)

Happens at Compile Time.

Methods have the same name but different parameters.

C#

```C#
public void Add(int a, int b) { ... }
public void Add(double a, double b) { ... }
public void Add(string a, string b) { ... }
```

#### B. Dynamic Polymorphism (Overriding)

Happens at Runtime.

Methods have the same name and parameters, but different implementations in Child classes using virtual and override.

C#

```C#
class Animal 
{ 
    public virtual void Eat() => Console.WriteLine("Eating generic food"); 
}

class Rabbit : Animal 
{ 
    // This REPLACES the parent method
    public override void Eat() => Console.WriteLine("Eating carrots"); 
}
```

### 4. Why use Polymorphism?

1. **Flexibility:** You can write code that works on the **Parent** type (e.g., `Feed(Animal a)`), and it will automatically work for any new Child classes you create in the future (`Lion`, `Tiger`, etc.) without changing the code.
    
2. **Clean Code:** It removes the need for giant `if-else` or `switch` statements.
    

**Without Polymorphism (Bad):**

C#

```C#
if (type == "Dog") dog.Bark();
else if (type == "Cat") cat.Meow();
else if (type == "Bird") bird.Chirp();
```

**With Polymorphism (Good):**

C#

```C#
animal.MakeSound(); // Automatically picks the right one
```