
---

## C# Interfaces

An **Interface** is a **contract**. It defines **what** a class must do, but not **how** it does it.

Think of it like a USB port.

- The USB standard (Interface) says: "You must have 4 pins and fit this shape."
    
- It doesn't care if the device is a Mouse, a Keyboard, or a Fan. As long as they fit the shape (implement the interface), they work.
    

### 1. Naming Convention

Interfaces always start with a capital **`I`**.

- `IAnimal`
    
- `IDisposable`
    
- `IEnumerable`
    

### 2. Syntax (The Contract)

An interface **cannot** contain code logic (bodies). It only contains signatures (Methods, Properties).

C#

```C#
// 1. Define the Interface
public interface IPayment
{
    // No fields allowed (int x;)
    // No method bodies allowed ({ ... })
    
    void Pay(double amount); // Just the signature
}
```

### 3. Implementation (Signing the Contract)

When a class implements an interface, it **promises** to write the code for every method defined in that interface. If it forgets one, the compiler throws an error.

C#

```C#
// 2. Implement the Interface using ':'
public class CreditCard : IPayment
{
    public void Pay(double amount)
    {
        Console.WriteLine($"Paid ${amount} with Visa.");
    }
}

public class PayPal : IPayment
{
    public void Pay(double amount)
    {
        Console.WriteLine($"Paid ${amount} with PayPal.");
    }
}
```

### 4. The Superpower: Multiple Interfaces

This is the main reason we use Interfaces.

A Class can only inherit from ONE Parent Class, but it can implement MANY Interfaces.

C#

```
// A Smartphone is a Computer, but it can also take photos and make calls.
public class SmartPhone : Computer, ICamera, IPhone
{
    // Must implement methods from ICamera AND IPhone
}
```

### 5. Polymorphism with Interfaces

You can treat different objects as the same Interface type. This allows you to write flexible code.

C#

```C#
// usage
IPayment method1 = new CreditCard();
IPayment method2 = new PayPal();

List<IPayment> transactions = new List<IPayment>();
transactions.Add(method1);
transactions.Add(method2);

foreach (IPayment method in transactions)
{
    // We don't know if it's a Card or PayPal, 
    // but we know it has a .Pay() method.
    method.Pay(100);
}
```

---

### Abstract Class vs Interface (Cheat Sheet)

|**Feature**|**Abstract Class**|**Interface**|
|---|---|---|
|**Logic**|Can have real code + abstract methods.|**No code** (only signatures).|
|**Inheritance**|Single (`: Animal`)|**Multiple** (`: IDrawable, IPrintable`)|
|**Fields**|Can have variables (`int x`).|**Cannot** have fields.|
|**Use when**|Objects are related (**Is-A**)<br><br>  <br><br>_(Dog is an Animal)_|Objects have a capability (**Can-Do**)<br><br>  <br><br>_(Dog can IWalk)_|
