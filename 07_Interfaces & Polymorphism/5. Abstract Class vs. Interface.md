
---

## C# Abstract Class vs Interface

Both **Abstract Classes** and **Interfaces** allow you to define contracts (rules) for your classes, but they serve different architectural purposes.

- **Abstract Class:** A **Template** (Partial implementation).
    
- **Interface:** A **Contract** (Pure definition).
    

### 1. What is an Abstract Class?

An abstract class is a class that **cannot be instantiated** directly (`new Abstract()`). It exists only to be inherited by other classes.

- **Contains:**
    
    - **Abstract members:** No code. Must be implemented by children.
        
    - **Concrete members:** Real code. Can be reused by children.
        
    - **State:** Can have fields (`int x;`) and Constructors.
        
- **Analogy:** A "Partially built house". The foundation and walls are there (Concrete), but the interior design is left to the owner (Abstract).
    

C#

```C#
public abstract class PrinterBase
{
    // Abstract: Child MUST define how to print
    public abstract void Print(string document); 

    // Concrete: Shared logic (All printers power on the same way)
    public virtual void PowerOn()
    {
        Console.WriteLine("Powering on...");
    }
}
```

### 2. What is an Interface?

An interface is a **pure contract**. It defines **what** a class must do, but never **how**.

- **Contains:** Only Method/Property signatures.
    
- **Restrictions:** No Fields, No Constructors.
    
- **Rule:** A class implementing it **must** provide code for **all** members.
    

C#

```C#
public interface IPrintable
{
    void Print(string document);
}

public interface IScannable
{
    void Scan();
}
```

### 3. Key Differences (Cheat Sheet)

|**Feature**|**Abstract Class**|**Interface**|
|---|---|---|
|**Purpose**|Shared functionality & Template.|Decoupling & Capabilities.|
|**Inheritance**|**Single** (`: Base`)|**Multiple** (`: IOne, ITwo`)|
|**Fields/State**|**Yes** (Can store variables).|**No** (Stateless).|
|**Constructors**|**Yes** (For initialization).|**No**.|
|**Access Modifiers**|Public, Protected, Private.|Implicitly Public.|
|**Changes**|Safer to add concrete methods later.|Breaking change (breaks all implementers).|

### 4. When to Use Which?

#### Use an **Abstract Class** when:

- You have **shared code** that multiple derived classes should use (Don't repeat yourself).
    
- You need to manage **state** (fields) across the hierarchy.
    
- The classes are closely related (**Is-A** relationship).
    
    - _Example:_ `PrinterBase` (All printers share state like `IsOn` or `PaperLevel`).
        

#### Use an **Interface** when:

- You only care about **capabilities**, not who the object is.
    
- You need **Multiple Inheritance** (A class needs to do multiple different things).
    
- The classes are unrelated (**Can-Do** relationship).
    
    - _Example:_ `MultiFunctionPrinter` implements `IPrintable` AND `IScannable`.
        

### 5. Combining Both (Best Practice)

In large systems, you often use both. You inherit from a base class for shared logic, and implement interfaces for specific skills.

C#

```C#
// Inherits shared logic (PowerOn) AND promises to be Printable
public class LaserPrinter : PrinterBase, IPrintable
{
    public override void Print(string doc) 
    {
        Console.WriteLine($"Laser printing: {doc}");
    }
}
```