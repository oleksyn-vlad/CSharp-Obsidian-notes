Here is the complete note on **Dictionaries** for your Obsidian vault.

---

## C# Dictionaries (`Dictionary<TKey, TValue>`)

A **Dictionary** is a collection that stores data in **Key-Value pairs**.

- **Key:** Must be unique (like an ID or username). Used to find data fast.
    
- **Value:** The actual data. Can be duplicates.
    
- **Analogy:** A real dictionary. The word is the **Key**, the definition is the **Value**.
    

It lives in `System.Collections.Generic`. (Similar to `std::map` or `std::unordered_map` in C++).

### 1. Declaration & Initialization

You must define **two** types: one for the Key, one for the Value.

C#

```C#
// Key is int (ID), Value is string (Name)
Dictionary<int, string> employees = new Dictionary<int, string>();

// Collection Initializer (Cleaner syntax)
var codes = new Dictionary<string, string>
{
    { "US", "United States" },
    { "UA", "Ukraine" },
    { "PL", "Poland" }
};
```

Here is the updated **Adding Items** section for your Dictionary note. You can replace the previous "Section 2" with this one, as it now covers all three methods including `TryAdd`.

---

### 2. Adding Items (3 Ways)

There are three ways to add items, and the difference is how they handle **duplicates**.

#### A. The Strict Way (`.Add`)

Use this when you are sure the key is new.

- **Behavior:** Throws an **Exception** (Crash) if the Key already exists.
    

C#

```C#
Dictionary<string, int> ages = new Dictionary<string, int>();
ages.Add("Tom", 25);

// ages.Add("Tom", 30); // CRASH! ArgumentException
```

#### B. The Overwrite Way (`[]`)

Use this when you want to save the "latest" version of data.

- **Behavior:** If Key exists -> **Overwrites** the old value. If Key is new -> Adds it.
    

C#

```C#
ages["Ana"] = 22; 
ages["Tom"] = 30; // Tom existed (25), now he is 30. No error.
```

#### C. The Safe Way (`.TryAdd`)

Use this when you want to keep the **original** data and ignore duplicates safely.

- **Behavior:** If Key exists -> **Does nothing** (Returns `false`). If Key is new -> Adds it (Returns `true`).
    

C#

```C#
// "Try to add Tom with age 50"
bool wasAdded = ages.TryAdd("Tom", 50);

// Result:
// wasAdded is 'false' (because Tom is already there).
// Tom's age is still 30 (Value was NOT overwritten).
```

### Summary: Handling Duplicates

|**Method**|**Syntax**|**If Key Exists...**|
|---|---|---|
|**`.Add(k, v)`**|`dict.Add("A", 1)`|**Crash** (Error)|
|**Indexer `[]`**|`dict["A"] = 1`|**Overwrite** (Update value)|
|**`.TryAdd(k, v)`**|`dict.TryAdd("A", 1)`|**Ignore** (Keep old value, return false)|```

### 3. Accessing Values (Reading)

Be careful! If you try to read a key that doesn't exist using `[]`, the program will crash (KeyNotFoundException).

#### A. Unsafe Access (Use only if sure)

C#

```C#
int tomAge = ages["Tom"]; // Works
// int unknown = ages["Ghost"]; // CRASH!
```

#### B. Safe Access (`TryGetValue`) - Recommended

This is the standard pattern to prevent crashes.

C#

```C#
if (ages.TryGetValue("Ana", out int result))
{
    Console.WriteLine($"Ana is {result} years old.");
}
else
{
    Console.WriteLine("User not found.");
}
```

#### C. Check Existence (`ContainsKey`)

C#

```C#
if (ages.ContainsKey("Tom"))
{
    // Do something...
}
```

### 4. Updating & Removing

C#

```C#
// Updating
// Just use the indexer
ages["Tom"] = 31; 

// Removing
// Returns true if found and removed, false if not found
bool wasRemoved = ages.Remove("Ana"); 
```

### 5. Iterating (Looping)

When you loop through a Dictionary, you get a `KeyValuePair` object.

C#

```C#
foreach (KeyValuePair<string, int> entry in ages)
{
    // entry.Key   -> The name
    // entry.Value -> The age
    Console.WriteLine($"{entry.Key} is {entry.Value} years old");
}

// You can also use 'var' to make it shorter
foreach (var entry in ages)
{
    Console.WriteLine($"{entry.Key}: {entry.Value}");
}
```

---

### Summary: List vs Dictionary

|**Feature**|**List <T>**|**Dictionary <Key, Value>**|
|---|---|---|
|**Access**|By Index (`list[0]`)|By Key (`dict["ID"]`)|
|**Order**|Ordered (0, 1, 2...)|Unordered (technically)|
|**Speed**|Slow to find specific item (Linear search)|**Extremely Fast** to find item by Key|
|**Use Case**|Collection of items (Inventory)|Lookups (Phonebook, ID system)|