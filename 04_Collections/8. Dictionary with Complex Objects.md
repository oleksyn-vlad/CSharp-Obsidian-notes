Here is the note on **Using Complex Objects in Dictionaries**.

---

## C# Dictionary with Complex Objects

In professional applications, the **Value** of a Dictionary is rarely a simple `string` or `int`. It is usually a **custom object** (a class).

This pattern is used to create **Lookup Tables** (like a database index). You use a unique ID (Key) to instantly retrieve a complete Object (Value).

### 1. The Setup (The Class)

Let's say we have a `Student` class.

C#

```C#
public class Student
{
    public int Id { get; set; }
    public string Name { get; set; }
    public double GPA { get; set; }
}
```

### 2. Declaration

The **Key** should be the unique identifier (like `Id`), and the **Value** is the `Student` object itself.

C#

```C#
// Key = int (Student ID)
// Value = Student (The whole object)
Dictionary<int, Student> studentMap = new Dictionary<int, Student>();
```

### 3. Adding Objects

You can create the object first, or create it inline.

C#

```C#
Student s1 = new Student { Id = 101, Name = "Tom", GPA = 3.5 };
Student s2 = new Student { Id = 102, Name = "Ana", GPA = 4.0 };

// Add them using the ID as the Key
studentMap.Add(s1.Id, s1);
studentMap.Add(s2.Id, s2);

// Inline syntax
studentMap.Add(103, new Student { Id = 103, Name = "Bob", GPA = 2.8 });
```

### 4. Accessing Data (The Important Part)

When you access the dictionary by Key, you get back a **Student object**. You can then access properties using the dot `.` operator immediately.

C#

```C#
// 1. Get the student with ID 102
// This is O(1) - Instant access, no looping required
Student result = studentMap[102];
Console.WriteLine(result.Name); // Output: Ana

// 2. Chaining (Shorthand)
// Get ID 101 -> Get their GPA
Console.WriteLine(studentMap[101].GPA); // Output: 3.5
```


### 5. Iterating

When looping, `entry.Value` is the whole object.

C#

```C#
foreach (KeyValuePair<int, Student> entry in studentMap)
{
    // entry.Key   -> 101
    // entry.Value -> Student Object
    
    Console.WriteLine($"ID: {entry.Key}, Name: {entry.Value.Name}");
}
```

### 6. Why use this over a `List<Student>`?

|**Feature**|**List<Student>**|**Dictionary<int, Student>**|
|---|---|---|
|**Finding by ID**|Slow. Must loop through the list (`Find(...)`).|**Instant.** (`dict[id]`).|
|**Memory**|Uses less memory.|Uses slightly more memory (overhead).|
|**Best For**|Iterating over all items.|Looking up specific items by ID.|


---

## C# Dictionary: .Values & .Keys

Sometimes you don't need the relationship (Key-Value pair). You just want a list of all the **Keys** (IDs) or all the **Values** (Data).

Dictionaries have two properties for this: `.Values` and `.Keys`.

### 1. `.Values` (Getting the Data)

This extracts **only** the values into a collection.

C#

```C#
Dictionary<int, string> employees = new Dictionary<int, string>
{
    { 101, "Tom" },
    { 102, "Ana" },
    { 103, "Bob" }
};

// Returns a collection of strings: "Tom", "Ana", "Bob"
// We don't care about the IDs here, just the names.
foreach (string name in employees.Values)
{
    Console.WriteLine(name);
}
```

### 2. `.Keys` (Getting the IDs)

This extracts **only** the keys.

C#

```C#
// Returns a collection of ints: 101, 102, 103
foreach (int id in employees.Keys)
{
    Console.WriteLine($"ID available: {id}");
}
```

### 3. Converting to a List (Common Task)

The `.Values` property returns a special collection type (not a List). If you need to manipulate it (sort it, remove items), you should convert it to a `List` using LINQ.

_Requires `using System.Linq;`_

C#

```C#
// Extract all names and turn them into a real List<string>
List<string> allNames = employees.Values.ToList();

// Now you can sort them
allNames.Sort(); 
```