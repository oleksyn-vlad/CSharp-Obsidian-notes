
---

## C# Constructor Inheritance (`base` keyword)

When one class inherits from another, the **Constructors** do not automatically "copy" over.

However, when you create an object of the Child class, C# **must** run the Parent constructor first to ensure the base part of the object is ready.

### 1. The Rule

If the Parent class constructor requires parameters, the Child class constructor **must** explicitly call it and pass those parameters up.

You do this using the `: base(...)` syntax.

### 2. Syntax Example

C#

```C#
// 1. PARENT CLASS
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }

    // Parent constructor requires 2 arguments
    public Person(string name, int age)
    {
        this.Name = name;
        this.Age = age;
        Console.WriteLine("Parent Constructor Called");
    }
}

// 2. CHILD CLASS
public class Employee : Person
{
    public string JobTitle { get; set; }

    // The Child constructor takes 3 arguments:
    // - 2 for the Parent (name, age)
    // - 1 for Itself (jobTitle)
    public Employee(string name, int age, string jobTitle) 
        : base(name, age) // <--- Sending data UP to Parent
    {
        this.JobTitle = jobTitle;
        Console.WriteLine("Child Constructor Called");
    }
}
```

### 3. Execution Order

When you create a child object, the **Parent** constructor actually runs _before_ the Child constructor finishes.

C#

```C#
// Usage
Employee emp = new Employee("Tom", 30, "Developer");

// Output Order:
// 1. Parent Constructor Called
// 2. Child Constructor Called
```

### 4. What if I don't use `base`?

If the Parent class has a **default constructor** (one with no parameters), C# calls it automatically implicitly (`: base()` is hidden).

But if the Parent **only** has a constructor with parameters (like the `Person` class above), and you forget `: base(...)`, the code will **not compile**.

> **Error:** _"Person does not contain a constructor that takes 0 arguments"_

---

### 5. Multi-Level Inheritance (Grandparent -> Parent -> Child)

When you have a chain of inheritance (e.g., `Object` -> `Person` -> `Employee` -> `Manager`), the rule remains the same: **Each class is responsible for calling its immediate parent.**

You cannot "skip" a generation. The Child calls the Parent, and the Parent calls the Grandparent.

#### The "Bucket Brigade" Analogy

Think of it like passing buckets of water up a hill.

1. **Child** collects all data (Name, Age, Job, StockOptions).
    
2. **Child** keeps its own data (`StockOptions`) and passes the rest (`Name, Age, Job`) up to **Parent**.
    
3. **Parent** keeps its data (`Job`) and passes the rest (`Name, Age`) up to **Grandparent**.
    
4. **Grandparent** initializes.
    

#### Code Example

C#

```C#
// 1. GRANDPARENT
class Entity
{
    public int Id { get; set; }
    public Entity(int id)
    {
        this.Id = id;
        Console.WriteLine("1. Entity Created");
    }
}

// 2. PARENT
class User : Entity
{
    public string Username { get; set; }

    // Receives ID and Username
    // Passes ID up to Entity
    public User(int id, string username) : base(id)
    {
        this.Username = username;
        Console.WriteLine("2. User Created");
    }
}

// 3. CHILD
class Admin : User
{
    public int AccessLevel { get; set; }

    // Receives EVERYTHING (Id, Username, AccessLevel)
    // Passes Id and Username up to User
    public Admin(int id, string username, int level) 
        : base(id, username) 
    {
        this.AccessLevel = level;
        Console.WriteLine("3. Admin Created");
    }
}

// --- Usage ---
// We provide all 3 pieces of data here
Admin myAdmin = new Admin(101, "admin_tom", 5);

// OUTPUT ORDER (Top-Down):
// 1. Entity Created
// 2. User Created
// 3. Admin Created
```